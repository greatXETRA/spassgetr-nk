<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verbessertes Pixelart Schiff Steuerungsspiel</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            background-color: #333;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        #speedControl {
            width: 120px;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="controls">
        <label for="autoSail">Automatisches Segeln: </label>
        <input type="checkbox" id="autoSail" checked>
        <br>
        <label for="speedControl">Geschwindigkeit: </label>
        <input type="range" id="speedControl" min="1" max="5" value="2">
    </div>

    <script>
        // Canvas und Kontext einrichten
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Stellt die Größe des Canvas auf die Fenstergröße ein
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // Bei Start und Größenänderung des Fensters aufrufen
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Spielkonstanten
        const TILE_SIZE = 16;
        const SCALE = 3;
        const DISPLAY_TILE_SIZE = TILE_SIZE * SCALE;
        
        // Farben
        const COLORS = {
            deepWater: '#1a3876',
            shallowWater: '#3f5ea8',
            waterHighlight: '#5a78c0',
            sand: '#d9c27e',
            grass: '#2d632f',
            dock: '#8b572a',
            dockShadow: '#573718',
            shipHull: '#573718',
            shipDeck: '#8b572a',
            shipSail: '#e0e0e0',
            shipSailShadow: '#c0c0c0',
            shipMast: '#573718',
            shipCabin: '#8b572a',
            shipCabinWindow: '#3b81f5'
        };
        
        // Automatische Steuerung
        const autoSailCheckbox = document.getElementById('autoSail');
        const speedControl = document.getElementById('speedControl');
        
        // Spielzustand
        const game = {
            ship: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                width: DISPLAY_TILE_SIZE * 2,
                height: DISPLAY_TILE_SIZE,
                speed: 2,
                rotation: 0,
                targetX: null,
                targetY: null,
                autoSailSpeed: 0.01,
                autoSailAngle: 0,
                waveOffset: 0
            },
            camera: {
                x: 0,
                y: 0
            },
            map: {
                chunks: [],
                chunkSize: 16, // in Tiles
                loadedRange: 2 // Wie viele Chunks in jede Richtung geladen werden
            },
            worldSeed: Math.random() * 10000 | 0,
            time: 0,
            waves: []
        };
        
        // Wellenanimation initialisieren
        for (let i = 0; i < 20; i++) {
            game.waves.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 10 + 5,
                speed: Math.random() * 0.5 + 0.5
            });
        }
        
        // Einfacher Perlin-Noise ähnlicher Zufallsgenerator
        function noise(x, y) {
            const seed = game.worldSeed;
            const value = Math.sin(x * 0.1 + seed) * Math.cos(y * 0.1 + seed) * 0.5 + 0.5;
            return value;
        }
        
        // Erstellt einen neuen Chunk an der angegebenen Position
        function generateChunk(chunkX, chunkY) {
            const chunk = {
                x: chunkX,
                y: chunkY,
                tiles: []
            };
            
            const chunkSize = game.map.chunkSize;
            const worldX = chunkX * chunkSize * DISPLAY_TILE_SIZE;
            const worldY = chunkY * chunkSize * DISPLAY_TILE_SIZE;
            
            for (let y = 0; y < chunkSize; y++) {
                for (let x = 0; x < chunkSize; x++) {
                    const absX = chunkX * chunkSize + x;
                    const absY = chunkY * chunkSize + y;
                    
                    // Generiere Höhenwert
                    const heightValue = noise(absX * 0.5, absY * 0.5);
                    
                    let tileType;
                    
                    // Bestimme Tile-Typ basierend auf Höhenwert
                    if (heightValue < 0.4) {
                        tileType = 'deepWater';
                    } else if (heightValue < 0.45) {
                        tileType = 'shallowWater';
                    } else if (heightValue < 0.5) {
                        tileType = 'sand';
                    } else {
                        tileType = 'grass';
                    }
                    
                    // Speichere Tile-Information
                    chunk.tiles.push({
                        x: x * DISPLAY_TILE_SIZE + worldX,
                        y: y * DISPLAY_TILE_SIZE + worldY,
                        type: tileType,
                        heightValue: heightValue
                    });
                    
                    // Generiere zufällig einen Steg (nur am Übergang zum Wasser)
                    if (tileType === 'sand' && noise(absX * 5, absY * 5) > 0.9) {
                        // Prüfe, ob benachbartes Tile Wasser ist
                        const leftValue = noise((absX - 1) * 0.5, absY * 0.5);
                        const rightValue = noise((absX + 1) * 0.5, absY * 0.5);
                        const upValue = noise(absX * 0.5, (absY - 1) * 0.5);
                        const downValue = noise(absX * 0.5, (absY + 1) * 0.5);
                        
                        // Erstelle Steg nur wenn in der Nähe von Wasser
                        if (leftValue < 0.45 || rightValue < 0.45 || upValue < 0.45 || downValue < 0.45) {
                            chunk.tiles.push({
                                x: x * DISPLAY_TILE_SIZE + worldX,
                                y: y * DISPLAY_TILE_SIZE + worldY,
                                type: 'dock'
                            });
                        }
                    }
                }
            }
            
            return chunk;
        }
        
        // Prüft, ob ein Chunk bereits existiert
        function getChunk(chunkX, chunkY) {
            return game.map.chunks.find(chunk => chunk.x === chunkX && chunk.y === chunkY);
        }
        
        // Aktualisiere die geladenen Chunks basierend auf der Schiffsposition
        function updateChunks() {
            const chunkSize = game.map.chunkSize;
            const displaySize = DISPLAY_TILE_SIZE;
            
            // Bestimme die aktuellen Chunk-Koordinaten des Schiffs
            const shipChunkX = Math.floor(game.ship.x / (chunkSize * displaySize));
            const shipChunkY = Math.floor(game.ship.y / (chunkSize * displaySize));
            
            // Lade Chunks im Umkreis
            const range = game.map.loadedRange;
            for (let dy = -range; dy <= range; dy++) {
                for (let dx = -range; dx <= range; dx++) {
                    const chunkX = shipChunkX + dx;
                    const chunkY = shipChunkY + dy;
                    
                    // Erstelle Chunk, wenn er noch nicht existiert
                    if (!getChunk(chunkX, chunkY)) {
                        game.map.chunks.push(generateChunk(chunkX, chunkY));
                    }
                }
            }
            
            // Entferne Chunks, die zu weit entfernt sind
            game.map.chunks = game.map.chunks.filter(chunk => {
                const distance = Math.max(
                    Math.abs(chunk.x - shipChunkX),
                    Math.abs(chunk.y - shipChunkY)
                );
                return distance <= range + 1;
            });
        }
        
        // Zeichnet einen Chunk
        function drawChunk(chunk) {
            for (const tile of chunk.tiles) {
                const screenX = tile.x - game.camera.x;
                const screenY = tile.y - game.camera.y;
                
                // Prüfe, ob das Tile auf dem Bildschirm ist
                if (screenX < -DISPLAY_TILE_SIZE || screenY < -DISPLAY_TILE_SIZE || 
                    screenX > canvas.width || screenY > canvas.height) {
                    continue;
                }
                
                // Zeichne das Tile
                ctx.fillStyle = COLORS[tile.type];
                ctx.fillRect(screenX, screenY, DISPLAY_TILE_SIZE, DISPLAY_TILE_SIZE);
                
                // Wasseranimation für tiefes und flaches Wasser
                if (tile.type === 'deepWater' || tile.type === 'shallowWater') {
                    const waveIntensity = tile.type === 'deepWater' ? 0.08 : 0.04;
                    const waveTime = game.time * 0.003;
                    const waveX = Math.sin(tile.x * 0.05 + waveTime) * waveIntensity;
                    const waveY = Math.cos(tile.y * 0.05 + waveTime) * waveIntensity;
                    
                    // Wellen zeichnen
                    ctx.fillStyle = COLORS.waterHighlight;
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(
                        screenX + DISPLAY_TILE_SIZE * (0.2 + waveX),
                        screenY + DISPLAY_TILE_SIZE * (0.2 + waveY),
                        DISPLAY_TILE_SIZE * 0.2,
                        DISPLAY_TILE_SIZE * 0.2
                    );
                    ctx.globalAlpha = 1.0;
                }
                
                // Zeichne Schatten für Steg
                if (tile.type === 'dock') {
                    ctx.fillStyle = COLORS.dockShadow;
                    ctx.fillRect(
                        screenX + DISPLAY_TILE_SIZE * 0.1,
                        screenY + DISPLAY_TILE_SIZE * 0.1,
                        DISPLAY_TILE_SIZE * 0.8,
                        DISPLAY_TILE_SIZE * 0.8
                    );
                }
            }
        }
        
        // Zeichnet die Schaumwellen
        function drawWaves() {
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = "#ffffff";
            
            for (const wave of game.waves) {
                const screenX = wave.x - game.camera.x % canvas.width;
                const screenY = wave.y - game.camera.y % canvas.height;
                
                // Welle zeichnen
                ctx.beginPath();
                ctx.arc(screenX, screenY, wave.size * (Math.sin(game.time * 0.01) * 0.2 + 0.8), 0, Math.PI * 2);
                ctx.fill();
                
                // Wellen bewegen
                wave.x += Math.cos(game.ship.rotation) * wave.speed;
                wave.y += Math.sin(game.ship.rotation) * wave.speed;
                
                // Wellen, die aus dem Bildschirm laufen, auf der anderen Seite wieder eintreten lassen
                if (screenX < -wave.size) wave.x += canvas.width + wave.size * 2;
                if (screenX > canvas.width + wave.size) wave.x -= canvas.width + wave.size * 2;
                if (screenY < -wave.size) wave.y += canvas.height + wave.size * 2;
                if (screenY > canvas.height + wave.size) wave.y -= canvas.height + wave.size * 2;
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        // Zeichnet das Schiff
        function drawShip() {
            const shipX = game.ship.x - game.camera.x;
            const shipY = game.ship.y - game.camera.y;
            
            // Schiffanimation (leichtes Schaukeln)
            const bobOffset = Math.sin(game.time * 0.02) * 2;
            
            ctx.save();
            ctx.translate(shipX + game.ship.width / 2, shipY + game.ship.height / 2 + bobOffset);
            ctx.rotate(game.ship.rotation);
            
            // Schiffsrumpf
            ctx.fillStyle = COLORS.shipHull;
            ctx.beginPath();
            ctx.moveTo(-game.ship.width / 2, 0);
            ctx.lineTo(-game.ship.width / 2 + DISPLAY_TILE_SIZE * 0.5, game.ship.height / 2);
            ctx.lineTo(game.ship.width / 2 - DISPLAY_TILE_SIZE * 0.5, game.ship.height / 2);
            ctx.lineTo(game.ship.width / 2, 0);
            ctx.lineTo(game.ship.width / 2 - DISPLAY_TILE_SIZE * 0.5, -game.ship.height / 2);
            ctx.lineTo(-game.ship.width / 2 + DISPLAY_TILE_SIZE * 0.5, -game.ship.height / 2);
            ctx.closePath();
            ctx.fill();
            
            // Deck
            ctx.fillStyle = COLORS.shipDeck;
            ctx.beginPath();
            ctx.moveTo(-game.ship.width / 2 + DISPLAY_TILE_SIZE * 0.6, -game.ship.height / 2 + DISPLAY_TILE_SIZE * 0.2);
            ctx.lineTo(-game.ship.width / 2 + DISPLAY_TILE_SIZE * 0.6, game.ship.height / 2 - DISPLAY_TILE_SIZE * 0.2);
            ctx.lineTo(game.ship.width / 2 - DISPLAY_TILE_SIZE * 0.6, game.ship.height / 2 - DISPLAY_TILE_SIZE * 0.2);
            ctx.lineTo(game.ship.width / 2 - DISPLAY_TILE_SIZE * 0.6, -game.ship.height / 2 + DISPLAY_TILE_SIZE * 0.2);
            ctx.closePath();
            ctx.fill();
            
            // Schiffskabine
            ctx.fillStyle = COLORS.shipCabin;
            ctx.fillRect(-DISPLAY_TILE_SIZE * 0.6, -DISPLAY_TILE_SIZE * 0.4, DISPLAY_TILE_SIZE * 1.2, DISPLAY_TILE_SIZE * 0.8);
            
            // Kabinenfenster
            ctx.fillStyle = COLORS.shipCabinWindow;
            ctx.fillRect(-DISPLAY_TILE_SIZE * 0.4, -DISPLAY_TILE_SIZE * 0.25, DISPLAY_TILE_SIZE * 0.25, DISPLAY_TILE_SIZE * 0.25);
            ctx.fillRect(DISPLAY_TILE_SIZE * 0.15, -DISPLAY_TILE_SIZE * 0.25, DISPLAY_TILE_SIZE * 0.25, DISPLAY_TILE_SIZE * 0.25);
            
            // Mast
            ctx.fillStyle = COLORS.shipMast;
            ctx.fillRect(-DISPLAY_TILE_SIZE * 0.1, -DISPLAY_TILE_SIZE * 1.5, DISPLAY_TILE_SIZE * 0.2, DISPLAY_TILE_SIZE * 1.5);
            
            // Segel (mit Animation)
            const sailWave = Math.sin(game.time * 0.03) * 0.1;
            
            ctx.fillStyle = COLORS.shipSailShadow;
            ctx.beginPath();
            ctx.moveTo(-DISPLAY_TILE_SIZE * 0.1, -DISPLAY_TILE_SIZE * 1.5);
            ctx.bezierCurveTo(
                DISPLAY_TILE_SIZE * (0.5 + sailWave), -DISPLAY_TILE_SIZE * 1.3,
                DISPLAY_TILE_SIZE * (0.6 + sailWave), -DISPLAY_TILE_SIZE * 0.8,
                DISPLAY_TILE_SIZE * 0.6, -DISPLAY_TILE_SIZE * 0.5
            );
            ctx.lineTo(-DISPLAY_TILE_SIZE * 0.1, -DISPLAY_TILE_SIZE * 0.5);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = COLORS.shipSail;
            ctx.beginPath();
            ctx.moveTo(-DISPLAY_TILE_SIZE * 0.1, -DISPLAY_TILE_SIZE * 1.5);
            ctx.bezierCurveTo(
                DISPLAY_TILE_SIZE * (0.4 + sailWave), -DISPLAY_TILE_SIZE * 1.2,
                DISPLAY_TILE_SIZE * (0.5 + sailWave), -DISPLAY_TILE_SIZE * 0.7,
                DISPLAY_TILE_SIZE * 0.5, -DISPLAY_TILE_SIZE * 0.5
            );
            ctx.lineTo(-DISPLAY_TILE_SIZE * 0.1, -DISPLAY_TILE_SIZE * 0.5);
            ctx.closePath();
            ctx.fill();
            
            // Zweites Segel (klein)
            ctx.fillStyle = COLORS.shipSailShadow;
            ctx.beginPath();
            ctx.moveTo(DISPLAY_TILE_SIZE * 0.1, -DISPLAY_TILE_SIZE * 0.5);
            ctx.bezierCurveTo(
                DISPLAY_TILE_SIZE * (0.5 + sailWave * 0.5), -DISPLAY_TILE_SIZE * 0.45,
                DISPLAY_TILE_SIZE * (0.5 + sailWave * 0.5), -DISPLAY_TILE_SIZE * 0.2,
                DISPLAY_TILE_SIZE * 0.4, 0
            );
            ctx.lineTo(DISPLAY_TILE_SIZE * 0.1, 0);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = COLORS.shipSail;
            ctx.beginPath();
            ctx.moveTo(DISPLAY_TILE_SIZE * 0.1, -DISPLAY_TILE_SIZE * 0.5);
            ctx.bezierCurveTo(
                DISPLAY_TILE_SIZE * (0.4 + sailWave * 0.5), -DISPLAY_TILE_SIZE * 0.4,
                DISPLAY_TILE_SIZE * (0.4 + sailWave * 0.5), -DISPLAY_TILE_SIZE * 0.1,
                DISPLAY_TILE_SIZE * 0.3, 0
            );
            ctx.lineTo(DISPLAY_TILE_SIZE * 0.1, 0);
            ctx.closePath();
            ctx.fill();
            
            // Bugsprit
            ctx.fillStyle = COLORS.shipMast;
            ctx.save();
            ctx.rotate(Math.PI / 8);
            ctx.fillRect(0, 0, DISPLAY_TILE_SIZE * 0.1, DISPLAY_TILE_SIZE * 0.7);
            ctx.restore();
            
            ctx.restore();
        }
        
        // Prüft Kollision mit Land
        function checkCollision() {
            const shipX = game.ship.x;
            const shipY = game.ship.y;
            
            for (const chunk of game.map.chunks) {
                for (const tile of chunk.tiles) {
                    if (tile.type !== 'deepWater' && tile.type !== 'shallowWater') {
                        const dx = shipX - tile.x;
                        const dy = shipY - tile.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < DISPLAY_TILE_SIZE) {
                            // Bei Landkollision die Geschwindigkeit reduzieren
                            game.ship.speed = 0.5;
                            return true;
                        }
                    }
                }
            }
            
            // Bei keiner Kollision normale Geschwindigkeit
            game.ship.speed = parseFloat(speedControl.value);
            return false;
        }
        
        // Aktualisiert die Spiellogik
        function update() {
            game.time++;
            
            // Aktualisiere Schiffsgeschwindigkeit vom Schieberegler
            game.ship.speed = parseFloat(speedControl.value);
            
            // Automatisches Segeln, wenn aktiviert
            if (autoSailCheckbox.checked) {
                // Ändere den Kurs leicht und zufällig
                game.ship.autoSailAngle += (Math.random() * 0.04 - 0.02);
                
                // Ab und zu den Kurs stärker ändern
                if (Math.random() < 0.01) {
                    game.ship.autoSailAngle += (Math.random() * 0.2 - 0.1);
                }
                
                // An Landmassen vorbei navigieren
                const lookAheadDistance = DISPLAY_TILE_SIZE * 5;
                const lookAheadX = game.ship.x + Math.cos(game.ship.rotation) * lookAheadDistance;
                const lookAheadY = game.ship.y + Math.sin(game.ship.rotation) * lookAheadDistance;
                
                for (const chunk of game.map.chunks) {
                    for (const tile of chunk.tiles) {
                        if (tile.type !== 'deepWater' && tile.type !== 'shallowWater') {
                            const dx = lookAheadX - tile.x;
                            const dy = lookAheadY - tile.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < DISPLAY_TILE_SIZE * 2) {
                                // Hinderniserkennung: Kurs ändern
                                game.ship.autoSailAngle += Math.PI / 4 * (Math.random() < 0.5 ? 1 : -1);
                            }
                        }
                    }
                }
                
                // Rotationswinkel aktualisieren
                game.ship.rotation += game.ship.autoSailAngle;
                
                // Stabilisiere den Kurs leicht
                game.ship.autoSailAngle *= 0.95;
                
                // Bewege Schiff in die aktuelle Richtung
                game.ship.x += Math.cos(game.ship.rotation) * game.ship.speed;
                game.ship.y += Math.sin(game.ship.rotation) * game.ship.speed;
            }
            // Manuelle Bewegung zum Ziel
            else if (game.ship.targetX !== null && game.ship.targetY !== null) {
                const dx = game.ship.targetX - game.ship.x;
                const dy = game.ship.targetY - game.ship.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    // Berechne Rotation
                    game.ship.rotation = Math.atan2(dy, dx);
                    
                    // Bewege Schiff in die Richtung
                    game.ship.x += (dx / distance) * game.ship.speed;
                    game.ship.y += (dy / distance) * game.ship.speed;
                } else {
                    // Ziel erreicht
                    game.ship.targetX = null;
                    game.ship.targetY = null;
                }
            }
            
            // Kollisionsprüfung
            checkCollision();
            
            // Aktualisiere Kamera, um das Schiff zu folgen
            game.camera.x = game.ship.x - canvas.width / 2 + game.ship.width / 2;
            game.camera.y = game.ship.y - canvas.height / 2 + game.ship.height / 2;
            
            // Aktualisiere Chunks basierend auf der Schiffsposition
            updateChunks();
        }
        
        // Hauptzeichenfunktion
        function draw() {
            // Lösche den Canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Zeichne alle Chunks
            for (const chunk of game.map.chunks) {
                drawChunk(chunk);
            }
            
            // Zeichne Wellen
            drawWaves();
            
            // Zeichne das Schiff
            drawShip();
        }
        
        // Game Loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Event-Listener für Mausklicks und Touch
        function handlePointerDown(e) {
            e.preventDefault();
            
            // Wenn automatisches Segeln aktiv ist, ignoriere manuelle Eingaben
            if (autoSailCheckbox.checked) {
                return;
            }
            
            let x, y;
            
            // Unterschiedliche Behandlung für Touch und Maus
            if (e.type === 'touchstart') {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } else {
                x = e.clientX;
                y = e.clientY;
            }
            
            // Konvertiere Bildschirmposition zu Weltposition
            game.ship.targetX = x + game.camera.x;
            game.ship.targetY = y + game.camera.y;
        }
        
        // Event-Listener registrieren
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
        
        // Event-Listener für Steuerungselemente
        autoSailCheckbox.addEventListener('change', function() {
            if (this.checked) {
                // Ziel zurücksetzen wenn automatisches Segeln aktiviert wird
                game.ship.targetX = null;
                game.ship.targetY = null;
            }
        });
        
        // Initialisiere einige Chunks um das Schiff herum
        updateChunks();
        
        // Starte das Spiel
        gameLoop();
    </script>
</body>
</html>
